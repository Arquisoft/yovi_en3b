ifndef::imagesdir[:imagesdir: ../images]

[[section-deployment-view]]


== Deployment View

ifdef::arc42help[]
[role="arc42help"]
****
.Content
The deployment view describes:

 1. technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and

2. mapping of (software) building blocks to that infrastructure elements.

Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments.

Especially document a deployment view if your software is executed as distributed system with more than one computer, processor, server or container or when you design and construct your own hardware processors and chips.

From a software perspective it is sufficient to capture only those elements of an infrastructure that are needed to show a deployment of your building blocks. Hardware architects can go beyond that and describe an infrastructure to any level of detail they need to capture.

.Motivation
Software does not run without hardware.
This underlying infrastructure can and will influence a system and/or some
cross-cutting concepts. Therefore, there is a need to know the infrastructure.

.Form

Maybe a highest level deployment diagram is already contained in section 3.2. as
technical context with your own infrastructure as ONE black box. In this section one can
zoom into this black box using additional deployment diagrams:

* UML offers deployment diagrams to express that view. Use it, probably with nested diagrams,
when your infrastructure is more complex.
* When your (hardware) stakeholders prefer other kinds of diagrams rather than a deployment diagram, let them use any kind that is able to show nodes and channels of the infrastructure.


.Further Information

See https://docs.arc42.org/section-7/[Deployment View] in the arc42 documentation.

****
endif::arc42help[]

=== Infrastructure Level 1

ifdef::arc42help[]
[role="arc42help"]
****
Describe (usually in a combination of diagrams, tables, and text):

* distribution of a system to multiple locations, environments, computers, processors, .., as well as physical connections between them
* important justifications or motivations for this deployment structure
* quality and/or performance features of this infrastructure
* mapping of software artifacts to elements of this infrastructure

For multiple environments or alternative deployments please copy and adapt this section of arc42 for all relevant environments.
****
endif::arc42help[]

image::deployment_level1.png["Infrastructure Level 1 Overview"]

Motivation::

The system is designed as a distributed web application. A central server hosts all the application logic and data (backend, game engine, database), while users access the game via standard web browsers. This centralized structure ensures data consistency and simplifies updates.

Quality and/or Performance Features::

* **Scalability:** The server uses Docker, allowing easy scaling of resources if the number of players increases.
* **Accessibility:** Users do not need to install any specific software; a web browser is sufficient.
* **Availability:** The server is accessible 24/7 via the internet.

Mapping of Building Blocks to Infrastructure::
* **Client Device:** Runs the `Frontend Application` (React) inside the browser.
* **External Bot Device:** Runs custom bot scripts developed by third parties.
* **YOVI Server:** Runs the `Backend (Users Service)`, `Game Engine (Rust)`, and `Database`.


=== Infrastructure Level 2

ifdef::arc42help[]
[role="arc42help"]
****
Here you can include the internal structure of (some) infrastructure elements from level 1.

Please copy the structure from level 1 for each selected element.
****
endif::arc42help[]

==== Docker Host (Server)

image::deployment_server.png["Docker Host Detail"]

This diagram illustrates the internal structure of the Server. The entire system is containerized using Docker, which ensures consistency across development and production environments.

* **Docker Host:** The physical or virtual server running the Docker Engine.
* **WebApp Container:** Hosts the React frontend application. It acts as the entry point for users and external bots. It forwards API requests to the backend services.
* **Users Service Container:** A Node.js/Express application that handles user authentication and history management. It is not directly accessible from the outside; it only accepts requests from the WebApp.
* **GameY Service Container:** The core game engine written in Rust. It processes game logic and validates moves. Like the Users Service, it is internal and accessed via the WebApp.
* **Database Container:** A PostgreSQL instance used for persistent storage of user data and game history. It is strictly isolated and only accessible by the Users Service via TCP port 5432.

==== Client Device

image::deployment_client.png["User Device Detail"]

This diagram illustrates the client-side deployment.

* **Client Device:** Represents the physical hardware (PC or Mobile) used by the player.
* **Web Browser:** The execution environment (e.g., Chrome, Firefox) that renders the application.
* **YOVI Web Client:** The React/TypeScript application artifact downloaded from the server and executed within the browser.

==== External Bot Device

image::deployment_bot.png["External Bot Device Detail"]

This diagram illustrates the deployment of an external bot that interacts with the YOVI system. Unlike human players, bots do not use a web browser; instead, they run as standalone scripts or applications.

* **External Bot Device:** Represents any machine (local computer or server) hosting a third-party bot.
* **Bot Runtime:** The environment required to execute the bot logic (e.g., Python Interpreter, Java Virtual Machine, or Node.js Runtime).
* **Bot Application:** The actual code developed by third parties (or the development team for testing). It communicates with the **YOVI System** exclusively via the HTTP/REST API (JSON) provided by the Web Application.
